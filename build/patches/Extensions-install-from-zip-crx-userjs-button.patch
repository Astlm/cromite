From 8e42e20aa4c81908459b9a5c5983600d987203a4 Mon Sep 17 00:00:00 2001
From: cromite <cromite@local>
Date: Fri, 19 Dec 2025 05:59:50 +0000
Subject: [PATCH] Extensions: install from .zip/.crx/.user.js via extensions
 page on Android\n\nFILE:Extensions-install-from-zip-crx-userjs-button.patch

---
 .../developer_private_functions_shared.cc     | 106 ++++++++++++++++++
 .../developer_private_functions_shared.h      |   3 +
 .../ui/webui/extensions/extensions_ui.cc      |   8 ++
 3 files changed, 117 insertions(+)

diff --git a/chrome/browser/extensions/api/developer_private/developer_private_functions_shared.cc b/chrome/browser/extensions/api/developer_private/developer_private_functions_shared.cc
index 15538e1b7f..be64aa1707 100644
--- a/chrome/browser/extensions/api/developer_private/developer_private_functions_shared.cc
+++ b/chrome/browser/extensions/api/developer_private/developer_private_functions_shared.cc
@@ -291,6 +291,14 @@ bool MatchesExtension(ui::FileInfo& file_info,
              : file_info.display_name.MatchesExtension(extension);
 }
 
+bool MatchesExtension(const ui::SelectedFileInfo& file_info,
+                      base::FilePath::StringViewType extension) {
+  if (!file_info.display_name.empty()) {
+    return base::FilePath(file_info.display_name).MatchesExtension(extension);
+  }
+  return file_info.path().MatchesExtension(extension);
+}
+
 }  // namespace
 
 namespace api {
@@ -836,8 +844,16 @@ void DeveloperPrivateLoadUnpackedFunction::ShowSelectFileDialog() {
   select_file_dialog_ = ui::SelectFileDialog::Create(
       this, std::make_unique<ChromeSelectFilePolicy>(web_contents));
 
+#if BUILDFLAG(IS_ANDROID)
+  // On Android, picking a directory is not very practical (SAF directory URIs
+  // need a follow-up step to reach a concrete file). Cromite uses this entry
+  // point to install extensions from a local file.
+  select_file_dialog_->SetAcceptTypes({u"*/*"});
+  ui::SelectFileDialog::Type file_type = ui::SelectFileDialog::SELECT_OPEN_FILE;
+#else
   ui::SelectFileDialog::Type file_type =
       ui::SelectFileDialog::SELECT_EXISTING_FOLDER;
+#endif  // BUILDFLAG(IS_ANDROID)
   std::u16string title =
       l10n_util::GetStringUTF16(IDS_EXTENSION_LOAD_FROM_DIRECTORY);
   const base::FilePath last_directory =
@@ -856,7 +872,11 @@ void DeveloperPrivateLoadUnpackedFunction::FileSelected(
     const ui::SelectedFileInfo& file,
     int index) {
   select_file_dialog_.reset();
+#if BUILDFLAG(IS_ANDROID)
+  StartFileInstall(file);
+#else
   StartFileLoad(file.path());
+#endif  // BUILDFLAG(IS_ANDROID)
 }
 
 void DeveloperPrivateLoadUnpackedFunction::FileSelectionCanceled() {
@@ -866,6 +886,92 @@ void DeveloperPrivateLoadUnpackedFunction::FileSelectionCanceled() {
   Finish(Error(kFileSelectionCanceled));
 }
 
+void DeveloperPrivateLoadUnpackedFunction::StartFileInstall(
+    const ui::SelectedFileInfo& selected_file) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  const base::FilePath file_path = selected_file.path();
+  const base::FilePath::StringType display_name =
+      selected_file.display_name.empty()
+          ? file_path.BaseName().value()
+          : selected_file.display_name;
+
+  auto finish_with_error = [this](const std::string& error) {
+    Finish(Error(error));
+  };
+
+  if (MatchesExtension(selected_file, FILE_PATH_LITERAL(".zip"))) {
+    ExtensionRegistrar* registrar = ExtensionRegistrar::Get(browser_context());
+    ZipFileInstaller::DoneCallback register_callback =
+        MakeRegisterInExtensionServiceCallback(browser_context());
+
+    auto installer = ZipFileInstaller::Create(
+        GetExtensionFileTaskRunner(),
+        base::BindOnce(
+            [](DeveloperPrivateLoadUnpackedFunction* self,
+               ZipFileInstaller::DoneCallback register_callback,
+               const base::FilePath& zip_file, const base::FilePath& unzip_dir,
+               const std::string& error) mutable {
+              std::move(register_callback).Run(zip_file, unzip_dir, error);
+              if (!error.empty() || unzip_dir.empty()) {
+                self->Finish(
+                    self->Error(error.empty() ? "Install failed" : error));
+                return;
+              }
+
+              self->Finish(self->NoArguments());
+            },
+            base::Unretained(this), std::move(register_callback)));
+
+    installer->InstallZipFileToUnpackedExtensionsDir(
+        file_path, registrar->unpacked_install_directory());
+    return;
+  }
+
+  if (MatchesExtension(selected_file, FILE_PATH_LITERAL(".crx")) ||
+      MatchesExtension(selected_file, FILE_PATH_LITERAL(".user.js"))) {
+    content::WebContents* web_contents = GetSenderWebContents();
+    if (!web_contents) {
+      finish_with_error(kCouldNotFindWebContentsError);
+      return;
+    }
+
+    auto prompt = std::make_unique<ExtensionInstallPrompt>(web_contents);
+    scoped_refptr<CrxInstaller> crx_installer =
+        CrxInstaller::Create(browser_context(), std::move(prompt));
+    crx_installer->set_error_on_unsupported_requirements(true);
+    crx_installer->set_off_store_install_allow_reason(
+        CrxInstaller::OffStoreInstallAllowedFromSettingsPage);
+    crx_installer->set_install_immediately(true);
+
+    crx_installer->AddInstallerCallback(base::BindOnce(
+        [](DeveloperPrivateLoadUnpackedFunction* self,
+           const std::optional<CrxInstallError>& result) {
+          if (!result.has_value()) {
+            self->Finish(self->NoArguments());
+            return;
+          }
+
+          self->Finish(self->Error(base::UTF16ToUTF8(result->message())));
+        },
+        base::Unretained(this)));
+
+    if (MatchesExtension(selected_file, FILE_PATH_LITERAL(".user.js"))) {
+      base::FilePath fake_download_path =
+          base::FilePath(FILE_PATH_LITERAL("/"))
+              .Append(base::FilePath(display_name));
+      crx_installer->InstallUserScript(
+          file_path, net::FilePathToFileURL(fake_download_path));
+    } else {
+      crx_installer->InstallCrx(file_path);
+    }
+
+    return;
+  }
+
+  finish_with_error("Unsupported file type");
+}
+
 void DeveloperPrivateLoadUnpackedFunction::StartFileLoad(
     base::FilePath file_path) {
 #if BUILDFLAG(IS_ANDROID)
diff --git a/chrome/browser/extensions/api/developer_private/developer_private_functions_shared.h b/chrome/browser/extensions/api/developer_private/developer_private_functions_shared.h
index 5420c03f49..7ba91d6003 100644
--- a/chrome/browser/extensions/api/developer_private/developer_private_functions_shared.h
+++ b/chrome/browser/extensions/api/developer_private/developer_private_functions_shared.h
@@ -313,6 +313,9 @@ class DeveloperPrivateLoadUnpackedFunction
   // Shows the file picker dialog.
   void ShowSelectFileDialog();
 
+  // Starts installing an extension/userscript from a selected file.
+  void StartFileInstall(const ui::SelectedFileInfo& file);
+
   // Starts loading the given `file_path`.
   void StartFileLoad(const base::FilePath file_path);
 
diff --git a/chrome/browser/ui/webui/extensions/extensions_ui.cc b/chrome/browser/ui/webui/extensions/extensions_ui.cc
index e0cfa3131b..118253bfa3 100644
--- a/chrome/browser/ui/webui/extensions/extensions_ui.cc
+++ b/chrome/browser/ui/webui/extensions/extensions_ui.cc
@@ -426,6 +426,14 @@ content::WebUIDataSource* CreateAndAddExtensionsSource(Profile* profile,
   };
   source->AddLocalizedStrings(kLocalizedStrings);
 
+#if BUILDFLAG(IS_ANDROID)
+  // On Android, Cromite exposes extensions installation via picking a local
+  // `.zip`/`.crx`/`.user.js` file rather than selecting an unpacked directory.
+  // Keep the existing i18n keys but override the strings only for Android.
+  source->AddString("toolbarLoadUnpacked", u"+ (from .zip/.crx/.user.js)");
+  source->AddString("toolbarLoadUnpackedDone", u"Extension installed");
+#endif  // BUILDFLAG(IS_ANDROID)
+
   // Add localized generic strings that need '&' to be removed from them.
   webui::AddLocalizedString(source, "edit", IDS_EDIT);
 
-- 
2.47.3

